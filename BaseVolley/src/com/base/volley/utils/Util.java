package com.base.volley.utils;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.text.SimpleDateFormat;import java.util.regex.Matcher;import java.util.regex.Pattern;import android.annotation.SuppressLint;import android.content.Context;import android.content.Intent;import android.content.res.Configuration;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.os.StatFs;import android.text.TextUtils;import com.base.volley.utils.logger.Logger;public final class Util {	// application 上下文	// public static Context mContext;	// 汉字	public static final int CHINESE = 0;	// 数字或字母	public static final int NUMBER_OR_CHARACTER = 1;	// 数字和字母	public static final int NUMBER_CHARACTER = 2;	// 数字、字母、汉字	public static final int MIX = 3;		public static final int IO_BUFFER_SIZE = 20 * 1024;		private static final String HTTP_PREFIX = "http://";	public static final String TAG = "Util";	private Util() {	}	public static final int EXCEPTION = -1;	public static String getBundleValue(Bundle bundle, String label,			String Default, boolean throwException) {		String value = null;		try {			value = bundle.getString(label);		} catch (Exception e) {			if (throwException) {				Logger.e("F.getBundleValue()", e);			} else {				Logger.e("throw Exception:  get String Bundle label " + label						+ " is null");			}		}		if (TextUtils.isEmpty(value)) {			return Default;		}		return value;	}	/**	 * 传入秒, 返回格式化的String	 **/	public static String formatTime(long time) {		String minute = "" + time / 60;		String second = "" + time % 60;		if (minute.length() == 1)			minute = "0" + minute;		if (second.length() == 1)			second = "0" + second;		return minute + "分" + second + "秒";	}	// /**	// * 判断字符串是否为空	// */	// public static boolean isNull(String str) {	// return str == null || str.length() == 0;	// }	/** 传入秒, 返回格式化的String */	public static String formatTime(double s) {		try {			long msec = (long) s;			String minutes, seconds;			seconds = "00" + (msec) % 60;			minutes = "" + (msec / 60);			if (minutes.length() == 1)				minutes = "0" + minutes;			seconds = seconds.substring(seconds.length() - 2, seconds.length());			String times = minutes + ":" + seconds;			return times;		} catch (Exception e) {			Logger.e("ERROR formatTime() e=" + e.toString());			return "";		}	}	public static String URLEncoder(String s) {		if (s == null || s.trim().length() == 0)			return "";		try {			s = URLEncoder.encode(s, "UTF-8");		} catch (UnsupportedEncodingException e) {			return "";		} catch (NullPointerException e) {			return "";		}		return s;	}	/** 是否是MD5值 */	public static boolean isMD5(String s) {		if (s != null && s.length() == 32)			return true;		return false;	}	/** 获得MD5串 */	public static String md5(final String s) {		try {			MessageDigest digest = java.security.MessageDigest					.getInstance("MD5");			digest.update(s.getBytes());			byte messageDigest[] = digest.digest();			StringBuffer hexString = new StringBuffer();			for (int i = 0; i < messageDigest.length; i++) {				String h = Integer.toHexString(0xFF & messageDigest[i]);				while (h.length() < 2)					h = "0" + h;				hexString.append(h);			}			return hexString.toString();		} catch (Exception e) {			Logger.e("Util.md5()", e);			return "";		}	}	/**	 * @return 图片地址的特征字串	 */	public static String getPosterImgUrlTrait(String imgUrl) {		String s;		try {			s = URLEncoder.encode(imgUrl.replace("*", ""), "UTF-8");		} catch (UnsupportedEncodingException e) {			Logger.e("Util#getPosterImgUrlTrait()", e);			s = "";		}		return s;	}	private final static String LINE_SEPARATOR = System			.getProperty("line.separator");	public static String convertStreamToString(InputStream is) {		/*		 * To convert the InputStream to String we use the		 * BufferedReader.readLine() method. We iterate until the BufferedReader		 * return null which means there's no more data to read. Each line will		 * appended to a StringBuilder and returned as String.		 */		final BufferedReader reader = new BufferedReader(new InputStreamReader(				is));		final StringBuilder sb = new StringBuilder();		String line = null;		try {			while ((line = reader.readLine()) != null) {				sb.append(line);				sb.append(LINE_SEPARATOR);			}		} catch (Exception e) {			e.printStackTrace();		} finally {			try {				reader.close();			} catch (Exception e1) {				e1.printStackTrace();			}			try {				is.close();			} catch (Exception e2) {				e2.printStackTrace();			}		}		return sb.toString();	}		public static String buildHttpErrorMsg(String status, int code, String desc) {		return new StringBuilder().append("{\"status\":\"").append(status)				.append("\",\"code\":").append(code).append(",\"desc\":\"")				.append(desc).append("\"}").toString();	}	public static void deleteFile(final File file) {		if (file == null)			return;		if (file.exists()) { // 判断文件是否存在			if (file.isFile()) { // 判断是否是文件				file.delete(); // delete()方法 你应该知道 是删除的意思;				return;			} else if (file.isDirectory()) { // 否则如果它是一个目录				File files[] = file.listFiles(); // 声明目录下所有的文件 files[];				if (files != null) {					for (int i = 0; i < files.length; i++) { // 遍历目录下所有的文件						deleteFile(files[i]); // 把每个文件												// 用这个方法进行迭代//(错了,这里叫递归,刘仲男注)					}				}			}			file.delete();		}	}	/**	 * TODO 判断网络状态是否可用	 * 	 * @return true: 网络可用 ; false: 网络不可用	 */	public static boolean hasInternet() {		ConnectivityManager m = (ConnectivityManager) Profile.mContext				.getSystemService(Context.CONNECTIVITY_SERVICE);		if (m == null) {			Logger.d("NetWorkState", "Unavailabel");			return false;		} else {			try {				NetworkInfo[] info = m.getAllNetworkInfo();				if (info != null) {					for (int i = 0; i < info.length; i++) {						if (info[i].getState() == NetworkInfo.State.CONNECTED) {							Logger.d("NetWorkState", "Availabel");							return true;						}					}				}			} catch (Exception e) {			}			try {				NetworkInfo info = m.getActiveNetworkInfo();				if (info != null) {					return info.isConnected();				}			} catch (Exception e1) {				return false;			}		}		return false;	}	/**	 * @return 是否是wifi网络	 */	public static boolean isWifi() {		ConnectivityManager m = (ConnectivityManager) Profile.mContext				.getSystemService(Context.CONNECTIVITY_SERVICE);		NetworkInfo n = m.getActiveNetworkInfo();		if (n != null && n.getType() == ConnectivityManager.TYPE_WIFI)			return true;		return false;	}	// public static String formatDuration(int second) {	// int hh = 0;	// int mm = 0;	// if (second >= 3600)	// hh = second / 3600;	// if ((second - 3600 * hh) >= 60)	// mm = (second - 3600 * hh) / 60;	// if (hh == 0)	// return String.format("%1$02d:%2$02d", mm, second - 3600 * hh - 60	// * mm);	// else	// return String.format("%1$02d:%2$02d:%3$02d", hh, mm, second - 3600	// * hh - 60 * mm);	// }	// public static boolean checkUserNickName(String line) {	// Pattern p = Pattern.compile("[^0-9a-zA-Z_\u4e00-\u9fa5]+");	// Matcher m = p.matcher(line);	// return !m.find();	// }	// public static boolean checkPassword(String line) {	// Pattern p = Pattern.compile("[^0-9a-zA-Z]+");	// Matcher m = p.matcher(line);	// return !m.find();	// }	/**	 * 验证码， 可以输入字母大小写都可以，还有数字	 * 	 * @param line	 *            输入	 * @param length	 *            长度	 * @return	 */	public static boolean checkVerificationCode(String line, int length) {		if (line.contains(" ")) {			return false;		}		Pattern p = Pattern.compile("[^0-9a-zA-Z]+");		Matcher m = p.matcher(line);		return !m.find() && line.length() == length;	}	// public static int getEnNZhMixStringLength(String str) {	// return str.length() + getChineseCharCount(str);	// }	/** Returns 是否有SD卡 */	public static boolean hasSDCard() {		if (Environment.MEDIA_MOUNTED.equals(Environment				.getExternalStorageState()))			return true;		return false;	}	// public static String readStream(InputStream inputStream) throws Exception	// {	// ByteArrayOutputStream outStream = new ByteArrayOutputStream();	// byte[] buffer = new byte[1024];	// int len = 0;	// while ((len = inputStream.read(buffer)) != -1) {	// outStream.write(buffer, 0, len);	// }	// outStream.close();	// inputStream.close();	// return new String(outStream.toByteArray());	// }	public static String join(Object... objs) {		if (objs == null)			return null;		StringBuffer result = new StringBuffer();		int i = 0;		for (Object obj : objs) {			result.append(obj + "");			if (i != objs.length - 1)				result.append(",");			i++;		}		return result.toString();	}	/** int型的这个不能省略,因为int转字符串的时候有问题 */	public static String join(int[] numbers) {		String result = "";		int i = 0;		for (int num : numbers) {			result += num;			if (i != numbers.length - 1)				result += ",";			i++;		}		return result;	}	/** long型的这个不能省略,因为long转字符串的时候有问题 */	public static String join(long[] numbers) {		String result = "";		int i = 0;		for (long num : numbers) {			result += num;			if (i != numbers.length - 1)				result += ",";			i++;		}		return result;	}	public static int[] string2int(String[] numbers) {		int[] nums = new int[numbers.length];		int i = 0;		try {			for (String num : numbers) {				nums[i] = Integer.parseInt(num);				i++;			}		} catch (NumberFormatException e) {			// TODO Auto-generated catch block			return nums;		}		return nums;	}	public static long[] string2long(String[] numbers) {		long[] nums = new long[numbers.length];		int i = 0;		try {			for (String num : numbers) {				nums[i] = Long.parseLong(num);				i++;			}		} catch (NumberFormatException e) {			// TODO Auto-generated catch block			return nums;		}		return nums;	}	private static final float scale = Profile.mContext.getResources()			.getDisplayMetrics().density;	private static final float scaledDensity = Profile.mContext.getResources()			.getDisplayMetrics().scaledDensity;	public static int dip2px(float dipValue) {		return (int) (dipValue * scale + 0.5f);	}	public static int px2dip(float pxValue) {		return (int) (pxValue / scale + 0.5f);	}	public static float sp2px(float spValue, int type) {		switch (type) {		case CHINESE:			return spValue * scaledDensity;		case NUMBER_OR_CHARACTER:			return spValue * scaledDensity * 10.0f / 18.0f;		default:			return spValue * scaledDensity;		}	}	public static boolean isNumber(String str) {		// return str.matches("^[-+]?(([0-9]+)([.]([0-9]+))?)$");		return str.matches("[\\d]+[.]?[\\d]+");	}	public static int judgeStringType(String input) {		String chineseRegex = "^[\u4e00-\u9fa5]*$";		String character = "^[A-Za-z]+$";		String numberRegex = "^[0-9]+$";		String numberAndChar = "[0-9]+[A-Za-z]+";		String numberAndChineseRegex = "[0-9]+[\u4e00-\u9fa5]+";		String charAndChineseRegex = "[A-Za-z]+[\u4e00-\u9fa5]+";		String all = "[0-9]+[\u4e00-\u9fa5]+[A-Za-z]+";		if (input.matches(chineseRegex)) {			return CHINESE;		} else if (input.matches(charAndChineseRegex)) {			return NUMBER_CHARACTER;		} else if (input.matches(character)) {			return NUMBER_OR_CHARACTER;		} else if (input.matches(numberRegex)) {			return NUMBER_OR_CHARACTER;		} else if (input.matches(numberAndChineseRegex)) {			return NUMBER_CHARACTER;		} else if (input.matches(all)) {			return MIX;		} else if (input.matches(numberAndChar)) {			return NUMBER_OR_CHARACTER;		} else			return CHINESE;	}	public static int numbersCount(String input) {		String numberRegex = "[0-9]";		int count = 0;		for (int i = 0; i < input.length(); i++) {			if ((input.charAt(i) + "").matches(numberRegex)) {				count++;			}		}		return count;	}	public static int ChineseCount(String input) {		String chineseRegex = "[\u4e00-\u9fa5]";		int count = 0;		for (int i = 0; i < input.length(); i++) {			if ((input.charAt(i) + "").matches(chineseRegex)) {				count++;			}		}		return count;	}	/**	 * TODO Return 是否是横屏	 * */	public static Boolean isLandscape(Context c) {		if (c.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {			return true;		}		return false;	}	/**	 * 跳转到浏览器	 */	public static void goBrowser(Context context, String url) {		Intent i = new Intent(Intent.ACTION_VIEW);		i.setData(Uri.parse(url));		context.startActivity(i);	}	/**	 * 转换文件大小	 * 	 * @param size	 *            单位为kb	 * @return	 */	public static String formatSize(float size) {		long kb = 1024;		long mb = (kb * 1024);		long gb = (mb * 1024);		if (size < kb) {			return String.format("%dB", (int) size);		} else if (size < mb) {			return String.format("%.1fK", size / kb); // 保留两位小数		} else if (size < gb) {			return String.format("%.1fM", size / mb);		} else {			return String.format("%.1fG", size / gb);		}	}	/**	 * TODO Returns SD卡信息	 * 	 * @return null为无SD卡;long[0]总大小;long[1]可用大小;(单位B)	 */	public static long[] getSDCardInfo() {		if (Environment.MEDIA_MOUNTED.equals(Environment				.getExternalStorageState())) {			long[] sdCardInfo = new long[2];			File sdcardDir = Environment.getExternalStorageDirectory();			StatFs sf = new StatFs(sdcardDir.getAbsolutePath());			long bSize = sf.getBlockSize();			long bCount = sf.getBlockCount();			long availBlocks = sf.getAvailableBlocks();			sdCardInfo[0] = bSize * bCount;// 总大小			sdCardInfo[1] = bSize * availBlocks;// 可用大小			return sdCardInfo;		}		return null;	}	/**	 * TODO 递归取得文件夹大小	 */	private static long getFileSize(File f) {		long size = 0;		if (f.isDirectory()) {			File flist[] = f.listFiles();			for (int i = 0; i < flist.length; i++) {				if (flist[i].isDirectory()) {					size = size + getFileSize(flist[i]);				} else {					size = size + flist[i].length();				}			}		} else {			size = size + f.length();		}		return size;	}	/**	 * 上次意图退出时间	 */	public static long LAST_EXIT_INTENT_TIME;	/**	 * 	 * @return 是否确认退出App	 */	public static final boolean isConfirmedExit() {		final long currentTime = System.currentTimeMillis();		if (currentTime - LAST_EXIT_INTENT_TIME < 3000) {			return true;		} else {			LAST_EXIT_INTENT_TIME = currentTime;			return false;		}	}	/**	 * 清空缓存文件目录	 * 	 * @param dir	 * @return	 */	public static final int clearCacheFolder(final File dir) {		int deletedFiles = 0;		if (dir != null && dir.isDirectory()) {			try {				for (File child : dir.listFiles()) {					// first delete subdirectories recursively					if (child.isDirectory()) {						deletedFiles += clearCacheFolder(child);					}					// then delete the files and subdirectories in this dir					// only empty directories can be deleted, so subdirs have					// been done first					if (child.delete()) {						deletedFiles++;					}				}			} catch (Exception e) {				Logger.e("Util#clearCacheFolder()", e);			}		}		return deletedFiles;	}	/**	 * 清空应用中的缓存	 * 	 * @param context	 */	private static void clearCache(final Context context) {		clearCacheFolder(context.getCacheDir());		if (Environment.getExternalStorageState().equals(				Environment.MEDIA_MOUNTED)) {			clearCacheFolder(context.getExternalCacheDir());		}	}	/*	 * MD5加密	 */	public static String getMD5Str(String str) {		MessageDigest messageDigest = null;		try {			messageDigest = MessageDigest.getInstance("MD5");			messageDigest.reset();			messageDigest.update(str.getBytes("UTF-8"));		} catch (NoSuchAlgorithmException e) {			Logger.e("F.getMD5Str()", e);		} catch (UnsupportedEncodingException e) {			Logger.e("F.getMD5Str()", e);		}		byte[] byteArray = messageDigest.digest();		StringBuffer md5StrBuff = new StringBuffer();		for (int i = 0; i < byteArray.length; i++) {			if (Integer.toHexString(0xFF & byteArray[i]).length() == 1)				md5StrBuff.append("0").append(						Integer.toHexString(0xFF & byteArray[i]));			else				md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));		}		// 16位加密，从第9位到25位		return md5StrBuff.substring(8, 24).toString().toUpperCase();	}	public static String getTime() {		SimpleDateFormat sDateFormat = new SimpleDateFormat(				"yyyy-MM-dd hh:mm:ss");		String date = sDateFormat.format(new java.util.Date());		date = date.replace("-", "");		date = date.replace("-", "");		date = date.replace(":", "");		date = date.replace(":", "");		date = date.replace(" ", "");		date = date.substring(2);		date += "000";		return date;	}	public static boolean isFinalUrl(String url) {		if (TextUtils.isEmpty(url))			return false;		url = url.toLowerCase().trim();		if (url.endsWith(".3gp") || url.endsWith(".mp4")				|| url.endsWith(".3gphd") || url.endsWith(".flv")				|| url.endsWith(".3gp") || url.endsWith(".m3u8"))			return true;		return false;	}	// 时间转换 00:23:13转换为 3453453(s)	// 修改105：09格式	public static int getSecond(String T) {		if (-1 == T.indexOf(":"))			return Integer.parseInt("T");		String time = new String(T);		time = ":::" + time;		int lastIndex = time.lastIndexOf(":");		String StrSecond = time.substring(lastIndex + 1);		time = time.substring(0, lastIndex);		lastIndex = time.lastIndexOf(":");		String StrMinutes = time.substring(lastIndex + 1);		time = time.substring(0, lastIndex);		lastIndex = time.lastIndexOf(":");		String StrHours = time.substring(lastIndex + 1);		time = null;		// F.out("StrSecond=" + StrSecond);		// F.out("StrMinutes=" + StrMinutes);		// F.out("StrHours=" + StrHours);		int second = 0;		try {			second += Integer.parseInt(StrSecond);		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		try {			second += (Integer.parseInt(StrMinutes)) * 60;		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		try {			second += (Integer.parseInt(StrHours)) * 3600;		} catch (Exception e) {			Logger.e("F.getSecond()", e);		}		// F.out("second=" + second);		return second;	}	static char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8',			'9', 'a', 'b', 'c', 'd', 'e', 'f' };	public static String byteToHexString(byte[] tmp) {		String s;		// 用字节表示就是 16 个字节		char str[] = new char[16 * 2]; // 每个字节用 16 进制表示的话，使用两个字符，		// 所以表示成 16 进制需要 32 个字符		int k = 0; // 表示转换结果中对应的字符位置		for (int i = 0; i < 16; i++) { // 从第一个字节开始，对 MD5 的每一个字节			// 转换成 16 进制字符的转换			byte byte0 = tmp[i]; // 取第 i 个字节			str[k++] = hexDigits[byte0 >>> 4 & 0xf]; // 取字节中高 4 位的数字转换,			// >>> 为逻辑右移，将符号位一起右移			str[k++] = hexDigits[byte0 & 0xf]; // 取字节中低 4 位的数字转换		}		s = new String(str); // 换后的结果转换为字符串		return s;	}	public static double getCpuMaxFreqFromFile() {		String str1 = "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq";		String content = "";		double maxfreq = 0.0;		FileReader fr = null;		BufferedReader localBufferedReader = null;		try {			fr = new FileReader(str1);			localBufferedReader = new BufferedReader(fr, 8192);			while ((content = localBufferedReader.readLine()) != null) {				maxfreq = Double.valueOf(content.trim());			}			return maxfreq;		} catch (Exception e) {			e.printStackTrace();		} catch (Error e) {			e.printStackTrace();		} finally {			if (fr != null) {				try {					fr.close();				} catch (IOException e) {					e.printStackTrace();				}			}			if (localBufferedReader != null) {				try {					localBufferedReader.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return maxfreq;	}	public static boolean isNeonSupportedFromFile() {		String str1 = "/proc/cpuinfo";		String content = "";		boolean isArmv7 = false;		boolean isNeno = false;		FileReader fr = null;		BufferedReader localBufferedReader = null;		try {			fr = new FileReader(str1);			localBufferedReader = new BufferedReader(fr, 8192);			while ((content = localBufferedReader.readLine()) != null) {				content = content.trim().toLowerCase();				if (content.contains("armv7")) {					isArmv7 = true;				} else if (content.contains("neon")) {					isNeno = true;				}			}		} catch (Exception e) {			e.printStackTrace();		} catch (Error e) {			e.printStackTrace();		} finally {			if (fr != null) {				try {					fr.close();				} catch (IOException e) {					e.printStackTrace();				}			}			if (localBufferedReader != null) {				try {					localBufferedReader.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return isArmv7 && isNeno;	}	public static double getTotalMemoryFromFile() {		String str1 = "/proc/meminfo";		String content = "";		double totalMem = 0.0;		FileReader fr = null;		BufferedReader localBufferedReader = null;		try {			fr = new FileReader(str1);			localBufferedReader = new BufferedReader(fr, 8192);			while ((content = localBufferedReader.readLine()) != null) {				content = content.trim().toLowerCase();				if (content.contains("memtotal")) {					totalMem = Double.valueOf(content.substring(							content.indexOf(":") + 1, content.indexOf("kb"))							.trim());					break;				}			}		} catch (Exception e) {			e.printStackTrace();		} catch (Error e) {			e.printStackTrace();		} finally {			if (fr != null) {				try {					fr.close();				} catch (IOException e) {					e.printStackTrace();				}			}			if (localBufferedReader != null) {				try {					localBufferedReader.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return totalMem;	}	public static boolean isTcl() {		boolean b = false;		try {			b = android.os.Build.BRAND.equals("Tcl")					|| android.os.Build.MODEL.indexOf(" Tcl") != -1;		} catch (Exception e) {			b = false;			e.printStackTrace();		}		return b;	}		public static void disableConnectionReuseIfNecessary() {		// HTTP connection reuse which was buggy pre-froyo		if (hasHttpConnectionBug()) {			System.setProperty("http.keepAlive", "false");		}	}		public static boolean hasHttpConnectionBug() {		return Build.VERSION.SDK_INT < Build.VERSION_CODES.FROYO;	}		/**	 * Check how much usable space is available at a given path.	 * 	 * @param path	 *            The path to check	 * @return The space available in bytes	 */	@SuppressLint("NewApi")	public static long getUsableSpace(File path) {		try {			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {				return path.getUsableSpace();			}			final StatFs stats = new StatFs(path.getPath());			return (long) stats.getBlockSize() * (long) stats.getAvailableBlocks();		} catch (Exception e) {			e.printStackTrace();		}		return 0;	}		/**	 * URL对应CDN处理	 * 	 * @param url	 * @return	 */	public static String urlToFileName(String url) {		try {			return url.substring(url.indexOf("/", url.indexOf(HTTP_PREFIX) + HTTP_PREFIX.length()) + 1);		} catch (Exception e) {			return url;		}	}	}